
//Blep click on Clicker2 STM32 - MikroBus 1

#include "Blep.h"
#include "services.h"
#include "acilib.h"



extern sfr sbit Blep_RST;
extern sfr sbit Blep_BONDED;
extern sfr sbit Blep_RDY;
extern sfr sbit Blep_REQ;
extern sfr sbit Blep_ACT;

char readBuff[32];
char writeBuff[32];

short bond[6] = {0x05,0x10,0xB4,0x00,0x20,0x00};
short connect[6] = {0x05,0x0F,0x00,0x00,0x20,0x00};
short Directconnect[2] = {0x01,0x1E};
short broadcast[6] = {0x05,0x1C,0x00,0x00,0x00,0x20};
short set_local_data[4] = {0x03,0x0D,0x02,0xAA};
char  sendData[] = {0x4, 0x15, 1, 0xaa, 0xbb};

volatile aci_evt_t p_aci_evt;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Blep_Write(unsigned short *dat, unsigned int len);
void Blep_Read();
void Blep_Setup();
char Blep_WaitForEvent(char event);



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Blep_Write(unsigned short *dat, unsigned int txLen)  {
char tmp, cnt, rxLen, rcvDummy, numOfRead;

  Blep_REQ = 0;
  while(Blep_RDY == 1);

  rcvDummy = SPI_Read(dat[0]);
  rxLen = SPI_Read(dat[1]);
  if(rxLen != 0) {
    readBuff[0] = rxLen;
  }

  for (cnt=2; (cnt<txLen + 1) || (cnt<rxLen + 2); cnt++)
  {

    if (cnt < txLen + 1) {
        tmp = SPI_Read(dat[cnt]); // transmit
    } else {
        tmp = SPI_Read(0); // receive only
    }

    if (cnt < rxLen + 2) { // receive
        readBuff[cnt-1] = tmp;
    }
  }

  Blep_REQ = 1;
  acil_decode_evt(readBuff, &p_aci_evt);

}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


void Blep_Read() {
  char cnt, dummy;
  
  while(Blep_RDY);
  Blep_REQ = 0;
  dummy =  SPI_Read(0);
  readBuff[0] = SPI_Read(dummy);
  if(readBuff[0] > 0) {
    for (cnt=0; cnt<readBuff[0]; cnt++){
        readBuff[cnt + 1] = SPI_Read(dummy);
    }
  }
  Blep_REQ = 1;
  acil_decode_evt(readBuff, &p_aci_evt);

}



////////////////////////////////////////////////////////////////////////////////
//                   GET EVENT CODE & EVENT STATUS
////////////////////////////////////////////////////////////////////////////////

char Blep_EventCode() {
  char cnt, dummy;
  while(Blep_RDY);
  Blep_REQ = 0;
  dummy =  SPI_Read(0);
  readBuff[0] = SPI_Read(dummy);
  if(readBuff[0] > 0) {
    for (cnt=0; cnt<readBuff[0]; cnt++){
        readBuff[cnt+1] = SPI_Read(dummy);
    }
  }
  Blep_REQ = 1;
  acil_decode_evt(readBuff, &p_aci_evt);
  return p_aci_evt.evt_opcode;
}

char Blep_EventOpcode() {
   return p_aci_evt.params.cmd_rsp.cmd_opcode;
}

char Blep_EventStatus() {
   return p_aci_evt.params.cmd_rsp.cmd_status;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

char Blep_WaitForEvent(char event) {

  while(1) {
    Blep_Read();
    if(p_aci_evt.evt_opcode == event) {
      break;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
aci_cmd_params_bond_t bondParam;
void Blep_Bond(uint16_t timeout, uint16_t adv_interval) {
  bondParam.timeout = timeout;
  bondParam.adv_interval = adv_interval;
  acil_encode_cmd_bond(writeBuff, (aci_cmd_params_bond_t*)&bondParam);
  Blep_Write(writeBuff, MSG_BOND_LEN);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Blep_DirectConnect() {
  acil_encode_direct_connect(writeBuff);
  Blep_Write(writeBuff, 2);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_connect_t p_aci_cmd_params_connect;
void Blep_Connect() {
  p_aci_cmd_params_connect.timeout = 0;
  p_aci_cmd_params_connect.adv_interval = 0x20;
  acil_encode_cmd_connect(writeBuff, &p_aci_cmd_params_connect);
  Blep_Write(writeBuff, MSG_CONNECT_LEN);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_disconnect_t p_aci_cmd_params_disconnect;
void Blep_Disconnect() {
  p_aci_cmd_params_disconnect.reason = ACI_REASON_TERMINATE;
  acil_encode_cmd_disconnect(writeBuff, &p_aci_cmd_params_disconnect);
  Blep_Write(writeBuff, MSG_CONNECT_LEN);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_send_data_t p_aci_cmd_params_send_data_t;
void Blep_SendData(uint8_t *dat, uint8_t len, uint8_t pipe) {

  p_aci_cmd_params_send_data_t.tx_data.pipe_number = pipe;
  memcpy(p_aci_cmd_params_send_data_t.tx_data.aci_data, dat, len);
  acil_encode_cmd_send_data(writeBuff, &p_aci_cmd_params_send_data_t, len);
  Blep_Write(writeBuff, MSG_SEND_DATA_BASE_LEN + len);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_open_remote_pipe_t p_aci_cmd_params_open_remote_pipe;
void Blep_OpenRemotePipe(uint8_t pipe) {
  p_aci_cmd_params_open_remote_pipe.pipe_number = pipe;
  acil_encode_cmd_open_remote_pipe(writeBuff, &p_aci_cmd_params_open_remote_pipe);

  Blep_Write(writeBuff, MSG_OPEN_REMOTE_PIPE_LEN);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Blep_SendDataAck(uint8_t pipe) {
  acil_encode_cmd_send_data_ack(writeBuff, pipe );
  Blep_Write(writeBuff, MSG_ACK_LEN);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void Blep_GetTemp() {
  acil_encode_cmd_temparature(writeBuff);
  Blep_Write(writeBuff, 1);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

static unsigned int tempValue;
char Blep_DecodeTemp() {

  Blep_GetTemp();
  Blep_WaitForEvent(ACI_EVT_CMD_RSP);
  tempValue = 0x8000;

  if(p_aci_evt.params.cmd_rsp.cmd_opcode == ACI_CMD_GET_TEMPERATURE) {
    if(p_aci_evt.params.cmd_rsp.cmd_status == 0) {
      tempValue = (p_aci_evt.params.cmd_rsp.params.get_temperature.temperature_value) >> 2;
    }
  }
  return (char)tempValue;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_set_local_data_t p_aci_cmd_params_set_local_data;
void Blep_SetLocalData(char *dat, char len, char pipe) {
  p_aci_cmd_params_set_local_data.tx_data.pipe_number = pipe;
  memcpy(p_aci_cmd_params_set_local_data.tx_data.aci_data, dat, len);
  acil_encode_cmd_set_local_data(writeBuff, &p_aci_cmd_params_set_local_data, len);
  Blep_Write(writeBuff, MSG_SET_LOCAL_DATA_BASE_LEN + len);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aci_cmd_params_test_t p_aci_cmd_params_test;
void Blep_TestModeState(char state) {
  p_aci_cmd_params_test.test_mode_change = state;
  acil_encode_cmd_set_test_mode(writeBuff, &p_aci_cmd_params_test);
  Blep_Write(writeBuff, 2);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

const TSetupMsg setupMsg[NB_SETUP_MESSAGES] = SETUP_MESSAGES_CONTENT;
void Blep_Setup() {

char reqLen;
char numOfMsg = 0;

   Blep_WaitForEvent(ACI_EVT_DEVICE_STARTED);

   Delay_ms(200);

   while(numOfMsg < NB_SETUP_MESSAGES)
   {
     reqLen = setupMsg[numOfMsg].buffer[0];
     Blep_Write(setupMsg[numOfMsg].buffer, reqLen);
     Blep_Read();
     numOfMsg++;
   }

   Blep_WaitForEvent(ACI_EVT_DEVICE_STARTED);

}